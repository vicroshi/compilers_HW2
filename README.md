Το πρόγραμμα μου πραγματοποιεί 2 περάσματα του κώδικα με δύο διαφορετικούς visitors.\
Στο πρώτο καλείται ένας `DeclVisitor`, εκεί έχουμε τις διάφορες δομές που κρατάμε\
για τα  symbol table μας (αναφέρονται με σχόλια στον κώδικα η χρήση του καθενός), τις δηλώνουμε ως   `public static` για να είναι προσβάσιμες στο δεύτερο pass.\
Στόχος του `DeclVisitor` είναι να προσπελάσει όλα τα σημεία του προγράμματος (με χρήση του visitor pattern) που υπάρχουν δηλώσεις.\
Για κάθε δήλωση αποθηκεύει στα symbol table την κατάλληλη πληροφορία, συγκεκριμένα για κάθε scope (κλάση ή μέθοδος κλάσης) πάει και δημιουργεί ένα `Map<String,String>` \
με κλειδιά τα ονόματα και τιμές τον τύπο τους. Στη συνέχεια κάθε scope αποθηκεύεται σε μία δομή  
`Map<String,Map<String,String>>`, με κλειδιά τα scopes και τιμές τα symbol tables τους. Για τις δηλώσεις κλάσεων τώρα,
έχει μία πιο απλή δομή `Map<String,String>` με κλειδιά τις κλάσεις και τιμές 
την κλάση από την οποία κληρονομεί, αν αυτή υπάρχει. Επίσης, στον `DeclVisitor` γίνεται και ο
έλεγχος για επαναορισμούς συμβόλων. Στο δεύτερο pass τώρα καλείται ο `TypeVisitor`, αυτός τώρα
χρησιμοποιεί την πληροφορία που έχει συλλέξει ο προηγούμενος για να κάνει σημασιολογικό έλεγχο. Ο έλεγχος γίνεται 
κυρίως στην αποτίμηση των expressions και στην εκτέλεση των statements. Φροντίζει να γίνεται
σωστό error handling και κάνει override πολλές μεθόδους για να αποτιμά τους τύπους των
εκφράσεων. Στην υλοποίησή μου, εντοπίζονται όλα τα σημασιολογικά λάθη και 
εκτυπώνονται με κατάλληλα μηνύματα. Εκτός από τις visit, έχουν φτιαχτεί και 
ορισμένες βοηθητικές μέθοδοι για να διευκολύνουν τον έλεγχο, και 2 δομές, 
η μία για τους βασικού τύπος της γλώσσας και η άλλη για μη-ορισμένα σύμβολα έτσι ώστε παρακάτω λάθη 
που προκαλούνται από αυτά να αγνοούνται (όπως και στον javac). Επίσης, υπάρχει και ο μετρητής 
errors, που μετράει τον αριθμό των λαθών, χρήσιμος για την εκτύπωση των offset μετά το 2ο pass. \
Γενικά στον κώδικα δουλεύω πολύ με string manipulation, τα scope χωρίζονται με το 
"::", δηλαδή είναι της μορφής "Classname" για τις κλάσεις και για τις
μεθόδους "Classname::Methodname", έτσι εύκολα απομονώνεται το συγκεκριμένο part του 
scope που χρειάζεται. Συνήθως το scope δίνεται σαν δεύτερο όρισμα στις visit.\
Ελπίζω τα σχόλια στον κώδικα να είναι αρκετά επεξηγηματικά, γιατί σε πολλά
σημεία μπορεί να γίνεται κάπως "messy".
Τρόπος εκτέλεσης:
Με την εντολή `make jars` φτιάχνονται οι κλάσεις των εργαλείων, του 
javacc αποθηκεύονται στο javacc directory, το οποίο έχω ορίσει στο minijava.jj
αρχείο γι' αυτό χρησιμοποιείστε αυτό, αλλιώς δεν θα δουλεύουν οι εντολές εκτέλεσης.
Μετα διαλέξτε μια make για την κάθε εκτέλεση.

`make main_normal` μεταγλωττίζει και εκτελεί τον κώδικα για όλα τα αρχεία στο minijava-examples-new/  

`make main_extra` μεταγλωττίζει και εκτελεί τον κώδικα για όλα τα αρχεία στο \
minijava-examples-new/minijava-extra

`make main_extra_error` μεταγλωττίζει και εκτελεί τον κώδικα για όλα τα αρχεία στο \
minijava-examples-new/minijava-error-extra  

`make main_baziotis` μεταγλωττίζει και εκτελεί τον κώδικα για όλα τα αρχεία στο \
minijava-testsuite/*.java




